python3 manage.py shell
db.create_all()
db.drop_all()

## 构造函数可选，可以不定义构造函数，一般有需求时才定义，可以在构造函数中制定 字段的默认值等


增
session.add(fake_user)

查

# 输出所有的user实例
返回的是User对象
session.query(User).order_by(User.id)

#查询所有User中所有的name字段
返回的是一个或多个元组。
session.query(User.name)

#查询所有User中所有的name字段，和fullname字段
返回的是一个或多个元组
session.query(User.name,User.fullname)

#filter_by过滤
session.query(User.name).filter_by(fullname ='Ed Jones')

#filter过滤
session.query(User.name).filter(User.fullname =='Ed Jones').filter(User.name=='ed')
常见的filter操作符:
query.filter(User.name == 'ed')                                 #相等
query.filter(User.name != 'ed')                                 #不相等
query.filter(User.name.like('%ed%'))                            #Like
query.filter(User.name.in_(['ed', 'wendy', 'jack']))            #in
query.filter(~User.name.in_(['ed', 'wendy', 'jack']))           #not in
query.filter(User.name == None)                                 #is null
query.filter(User.name != None)                                 #is not null
query.filter(User.name == 'ed', User.fullname == 'Ed Jones')    #and
query.filter(or_(User.name == 'ed', User.name == 'wendy'))      #or
query.filter(User.name.match('wendy'))                          #match


filter_by和filter两个方法，这两个方法都是用来做过滤的，区别在于，filter_by是传入关键字参数，
filter是传入条件判断，并且filter能够传入的条件更多更灵活

#排序
session.query(User).order_by(desc(User.name))

#去重查询，label是取别名
users = session.query(distinct(User.name).label('name')).all()


5.9 统计查询
user_count = session.query(User.name).order_by(User.name).count()#总数
age_avg = session.query(func.avg(User.age)).first()#平均值
age_sum = session.query(func.sum(User.age)).first(）#求和


query = session.query(User).filter(User.name.like('%ed')).order_by(User.id)
query.first()  #返回之多一个结果，以单项形式。
query.one()    #仅返回一个查询结果。当结果的数量不足一个或者多于一个时会报错


嵌入sql
session.query(User)。filter(text("id<224")).order_by(text("id")).all()
session.query(User).filter(text("id<:value and name=:name")).params(value=224, name='fred').order_by(User.id).one()



Pagination对象常用方法：
has_next :是否还有下一页
has_prev :是否还有上一页
items : 返回当前页的所有内容
next(error_out=False) : 返回下一页的Pagination对象
prev(error_out=False) : 返回上一页的Pagination对象
page : 当前页的页码(从1开始)
pages : 总页数
per_page : 每页显示的数量
prev_num : 上一页页码数
next_num :下一页页码数
query :返回 创建这个Pagination对象的查询对象
total :查询返回的记录总数
iter_pages(left_edge=2, left_current=2, right_current=5, right_edge=2)



关联（relationship）
一对一
一对多
多对多

lazy loading（懒加载）


MySQL外键起到约束作用，在数据库层面保证数据的完整性。
例如使用外键的CASCADE类型，当子表(例如user_info)关联父表(例如user)时，父表更新或删除时，子表会更新或删除记录，这个过程是数据库层面完成的。
早期企业系统数据库设计里面比较多，虽说帮程序员节省了delete、update操作，实际上增加了潜规则，也增加了软件复杂度，也会会减弱性能。

不使用级联删除了




